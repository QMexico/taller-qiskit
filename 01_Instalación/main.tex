%----------------------------------------------------------------------------
%                        Librerias para usar
%----------------------------------------------------------------------------
\documentclass[spanish]{beamer}
\usepackage{parskip}
\usepackage{ragged2e}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}         % para caracteres de todo tipo
\usepackage[spanish]{babel}         % para que coloque textos automáticos en español
\usepackage{tikz}                   % para uso de imágenes
\usetikzlibrary{quantikz}           % para dibujar circuitos
\usepackage{braket}                 % para notación de Dirac
\usepackage{hyperref}               % para personalizar links
\usepackage{listings}               % para snippets de código
 
%----------------------------------------------------------------------------
%                Definiciones de colores personalizados
%----------------------------------------------------------------------------

% Colores QMexico
\definecolor{QMexicoPurple}{RGB}{45, 30, 47}    % color morado del logo de QMexico
\definecolor{QMexicoPurple2}{RGB}{66, 36, 70}   % color morado del logo de QMexico (versión 2 para contrastar)
\definecolor{QMexicoYellow}{RGB}{253, 187, 65}  % color amarillo del logo de QMexico
\definecolor{QMexicoPink}{RGB}{238, 42, 111}    % color rosa mexicano del logo de QMexico

% Otros colores
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%            Personalización de los links dentro del documento
%----------------------------------------------------------------------------

\hypersetup{
  colorlinks,              % indicar que se desea color en las links
  allcolors=.,             % otras links con el color que ya tenían (dado por Beamer)
  urlcolor=QMexicoPink,    % solo cambiar el color de las urls
}

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%            Personalización de los links dentro del documento
%----------------------------------------------------------------------------

\hypersetup{
  colorlinks,              % indicar que se desea color en las links
  allcolors=.,             % otras links con el color que ya tenían (dado por Beamer)
  urlcolor=QMexicoPink,    % solo cambiar el color de las urls
}

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%                 Personalización de los snippet de código
%----------------------------------------------------------------------------

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%                        Imágenes con esquinas redondeadas
%----------------------------------------------------------------------------

\newsavebox{\picbox} % usar este comando si se desea que la imagen tenga esquinas redondeadas

\newcommand{\cutpic}[3]{
  \savebox{\picbox}{\includegraphics[width=#2]{#3}}
  \tikz\node [draw, rounded corners=#1, line width=4pt,
    color=white, minimum width=\wd\picbox,
    minimum height=\ht\picbox, path picture={
      \node at (path picture bounding box.center) {
        \usebox{\picbox}};
    }] {};}
%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%              Personalización de definiciones para Beamer
%----------------------------------------------------------------------------

\usetheme{Darmstadt}         % tema de Beamer
\useinnertheme{circles}      % quita las bullets en 3D

\setbeamercolor{palette primary}{bg=QMexicoPurple,fg=QMexicoYellow}
\setbeamercolor{palette secondary}{bg=QMexicoPurple2,fg=white}
%\setbeamercolor{palette tertiary}{bg=QMexicoPurple,fg=white}
%\setbeamercolor{palette quaternary}{bg=QMexicoPurple,fg=white}
\setbeamercolor{structure}{fg=QMexicoPurple} % itemize, enumerate, etc
\setbeamercolor{section in toc}{fg=QMexicoPink} % TOC sections
%\setbeamercolor{subsection in head/foot}{bg=QMexicoPurple,fg=white}

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
%                        Información del título
%----------------------------------------------------------------------------

\title[QMexico]  % opcional (dependiendo del tema de Beamer esto será mostrado o no)
{Curso de Qiskit}   % esto si será mostrado

\subtitle{Instalación e Introducción}  % por ejemplo: Qiskit Aer

\author{Pablo Gonzalez}  % sin son mas autores, usar "\and"

\institute[QMexico]  % (opcional)

\titlegraphic{\cutpic{0.25cm}{5cm}{QMexico-logo}}  % logo en página de título

\date[Agosto 2021]  % (opcional)
{Qiskit Summer Jam Mexico, Agosto 2021}

\logo{\cutpic{0.2cm}{1cm}{QMexico-logo-short.png}}
% logo en todas las slides

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
% Indicar que se debe colocar la tabla de contenido al comienzo de 
% cada sección y resalta la sección que va a comenzar
%----------------------------------------------------------------------------

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Tabla de Contenido}
    \tableofcontents[currentsection]
  \end{frame}
}

%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
\begin{document}

% Crear slide inicial (título)
\frame[plain]{\titlepage}

%----------------------------------------------------------------------------
% Colocar la tabla de contenido al inicio de la presentación
% pero después del título

\begin{frame}
\frametitle{Tabla de Contenido}
\tableofcontents
\end{frame}
%----------------------------------------------------------------------------
\section{Introducción}   
\newpage
\setlength{\parskip}{5mm}
\justify
\begin{frame}
\frametitle{Introducción}
Tradicionalmente, nuestros ordenadores han funcionado a base de unos y ceros para realizar la infinidad de maravillas y comodidades que estos han traido; pero con el paso del tiempo la situacion de tener que seguir usando un sistema que no permita la dualidad de situaciones ha llevado a encontrar un cierto limite con respecto a tareas mas complejas de realizar que navegar por internet.

Los computadores cuanticos teroricamente tienen una ventaja significativa contra los procesos que se pueden llevar a cabo en un ordenador normal, un ejemplo es la cyber seguridad y el desarrollo de calculos matematicos que le llevarian años en terminos de tiempo a los computadores actuales.
\end{frame}

\newpage
\setlength{\parskip}{5mm}
\begin{frame}
\frametitle{Introducción a la computación cuántica}
Aunque si bien, esto se escucha como ciencia ficción, los computadores actuales tienen el inconveniente de trabajarse por medio de la física cuántica, dejando en condiciones muy especiales para que estos puedan ser funcionales, ya que incluso la presencia de un observador, las variedades del ruido (ambiental, electromagnético, eléctrico, entre otros) pueden afectar a las operaciones que estas realicen.

Por tal motivo, su programación actualmente es un poco más avanzada que la realizada para los ordenadores convencionales, pero la ventaja que tenemos hoy contra hace 50 años en el pasado es que los ordenadores convencionales pueden simular de manera eficiente la respuesta real que se podría conseguir mediante un ordenador cuántico.
\end{frame}

\newpage
\setlength{\parskip}{5mm}
\begin{frame}
\frametitle{Introducción a la computación cuántica}
Es por ello que en este documento se estarán presentado, la forma de programar mediante herramientas en ordenadores convencionales gracias al uso de lenguajes de programación tales como Python donde es posible simular de manera precisa la respuesta de un ordenador cuántico mediante simuladores internos. 

Así como también el uso de tecnologías remotas o en la nube como las son herramientas de IBM donde puede utilizarse uno de los ordenadores cuánticos reales para realizar nuestros trabajos de computo.
\end{frame}

\newpage
\section{Instalción de Qiskit}
\begin{frame}
\frametitle{Instalción de Qiskit en Python}
\setlength{\parskip}{5mm}
\justify
Para realizar una instalación directa de lo que es Qiskit y sus simuladores se deberán seguir los siguientes pasos:

\begin{itemize}
        \item\textbf{ Abrimos el Command Prompt(CMD):}
         Para utilizar esta consola basta con ir a nuestro buscador (variando entre versiones de Windows) y poner ahí la palabra "cmd".
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD1.JPG}
    \end{itemize}
    \end{frame} 
    

    \begin{frame}
    \frametitle{Instalción de Qiskit en Python}
        Una vez hecho esto, daremos a buscar (o enter) y nos debería aparecer la siguiente ventana del buscador.
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD2.JPG}
    \end{frame} 

    \begin{frame}
    \frametitle{Instalción de Qiskit en Python}
        Le daremos click a la opción resaltada 'Ejecutar como administrador' solo por seguridad, pero puede funcionar incluso sin los permisos de administrador. Cuando termine de cargar, nos debe aparecer la siguiente ventana.
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD3.JPG}
    \end{frame} 

    \begin{frame}
    \frametitle{Actualizar nuestra versión de pip}
        Ya una vez en la ventana del CMD lo que necesitamos es acceder a Python desde la carpeta de aplicaciones locales de nuestro ordenador, por ello es necesario escribir la siguiente instrucción:

    \centering\includegraphics[width = 0.75\textwidth]{CMD4.JPG}
    \end{frame} 

    \begin{frame}
     \frametitle{Actualizar nuestra versión de pip}
       Al hacer esto, hemos llamado a nuestra versión de Python desde donde estaremos actualizando la versión de pip (21.1.2) mediante el comando:
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD5.JPG}
        
    \end{frame} 

    \begin{frame}
     \frametitle{Actualizar nuestra versión de pip}
        Cuando demos enter sobre este comando nos debe aparecer la siguiente ventana, donde se nos actualizara la versión de pip y al final su correspondiente mensaje donde la actualización fue exitosa.
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD6.JPG}
    \end{frame} 

    \begin{frame}
     \frametitle{Actualizar nuestra versión de pip}
        Añadido a esto para conocer la versión actual de nuestro pip basta con ejecutar el siguiente comando.
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD7.JPG}
    \end{frame} 

    

    \begin{frame}
    \frametitle{Instalar Qiskit de manera local}       
        Una vez tengas la versión más actualizada de pip, podrás ingresar el siguiente comando para instalar todas las librerías con las que se trabajaran de qiskit.
        
    \centering\includegraphics[width = 0.75\textwidth]{CMD8.JPG}
    \end{frame} 

    

    \begin{frame}
    \frametitle{Instalar complementos de Qiskit}
     Puede ocurrir que durante la instalación de qiskit nos den algunos errores, para ello sugerimos seguir los pasos a continuación para darle solución a estos problemas.
     \centering\includegraphics[width = \textwidth]{Diapositiva10.JPG}
    
     Esto ya que algunos complementos necesarios para la instalación de qiskit no vienen en nuestros ordenadores al instalar Python y necesitaremos instalarlos de manera manual para resolver estos conflictos.
   \end{frame} 

    

    \begin{frame}[fragile]
    \frametitle{Prueba de instalación exitosa} 
    
     Una vez haya terminado la instalación, es conveniente saber que estamos en la versión más actualizada de qiksit, para comprobar este punto te sugerimos introducir el siguiente comando.
     
       \begin{lstlisting}[language=Python]
        pip list\end{lstlisting}

      Para actualizar nuestra versión de Qiskit instalada a la más reciente, sugerimos introducir el siguiente comando y revisar que las versiones más actuales (26 de Junio del 2021) sean similares a la imagen más adelante.
      
    \end{frame} 

    \newpage
    \begin{frame}[fragile]
     \frametitle{Prueba de instalación exitosa} 
    \begin{lstlisting}[language=Python]
        pip install qiskit[visualization] -U
        pip install qiskit-nature -U
        pip install --upgrade qiskit==0.27.0 \end{lstlisting}
       
    \centering\includegraphics[width = 0.75\textwidth]{CMD10.jpg}
    \end{frame} 
    
    
\newpage
\section{Introducción a Qiskit}
\setlength{\parskip}{5mm}
\justify
\subsection{Librerias en Python}
\begin{frame}
\frametitle{Librerias en Python} 
Ahora que hemos instalado el paquete Qiskit en nuestro sistema, podemos empezar a escribir un pequeño código para empezar a comprender las configuraciones básicas de los sistemas de simulación de una computadora cuántica.

Pero antes de comenzar tratar código, vamos a darle una pequeña revisión a lo que es Qiskit, su uso y básicamente ¿qué es qiskit? Qiskit [kiss-kit] es un SDK(Software Development Kit) de código abierto para trabajar con computadoras cuánticas a nivel de pulsos, circuitos y módulos de aplicación. Lo que logra acelerar el desarrollo de aplicaciones cuánticas aportando toda una gama de herramientas para muchas aplicaciones distintas pero con la gran ventaja de eliminar por completo el ruido captado por un ordenador cuántico, dejando el resultado puro.

\end{frame} 
\begin{frame}
\frametitle{Librerias en Python} 
Para lograr dicho cometido, qiskit cuenta con una lista de simuladores que podremos llamar para realizar pruebas a nuestros circuitos, obteniendo con ello diferentes métodos para trabajar, resultados y comportamientos que son parte del funcionamiento de cada simulador. Como ejemplo serian Aer, Aqua, Terra, entre otros que serán abarcados a lo largo de este curso.

Para esta introducción estaremos manejando los simuladores de Aer mediante la IDE de PyCharm, la cual es la recomendada para trabajar esta parte del curso aunque si se desea usar otra IDE es perfectamente válido.

\end{frame} 

\begin{frame}
\frametitle{Librerias en Python} 
Para empezar a trabajar los circuitos cuánticos con Qiskit, deberemos llamar a las librerías con las que realizaremos nuestro primer circuito cuántico, para ello debemos definir lo siguiente en nuestra IDE.

 \includegraphics[width = \textwidth]{Diapositiva12.JPG}
 \end{frame} 
 \begin{itemize}
 \begin{frame}
 \frametitle{Elementos en Qiskit} 
     \item\textbf{1.- Modulo Qiskit:} 
     Es el modulo principal donde se alojan todas las herramientas con las que podemos disponer para realizar nuestras simulaciones.
     
     \item\textbf{2.- Librería de registros cuánticos:}
     Es la libreria con la que podemos agregar los qbits que necesitemos para nuestro trabajo, a partir de aqui podremos cambiarlos de signo, rotarlos, entre muchas otras acciones hasta cambiar las magnitudes de su estado.
     
     \item\textbf{3.- Librería de registros clásicos:}
     Para poder revisar el comportamiento de nuestros qbits necesitaremos una forma de medir su estado, la mejor manera es utilizando bits clásicos (0 o 1) y con esta librería podremos agregar los circuitos cuánticos.
   \end{frame} 
   \begin{frame}
   \frametitle{Elementos en Qiskit} 
     \item\textbf{4.- Librería de circuitos cuánticos:}
    Es la librería con la que podemos agregar los circuitos cuánticos que necesitemos en nuestro trabajo a partir de los qbits o bits clásicos registrados con anterioridad.
     
     \item\textbf{5.- Librería ejecuciones:}
    Con esta librería podremos realizar los trabajos de simulación seleccionando nuestros "disparos" o shots, el simulador para conseguir los resultados, entre otras cosas más.
     
     \item\textbf{6.- Librería del simulador:}
     Básicamente, son las características con las que ejecutaremos así como otras cosas con las que podemos dotar a nuestro circuito como un tipo de ruido que tenga nuestro sistema.
      \end{frame} 
    \end{itemize}
 \begin{frame}
 \frametitle{Elementos en Qiskit}    
Cabe resaltar, que el estudiante siempre revise los elementos con los que estará trabajando en el circuito que desee diseñar, mediante el uso de la documentación oficial de qiskit (\url{https://qiskit.org/}). Ahora, ya hemos comenzado a utilizar las librerías con las que crearemos nuestro circuito, ahora utilizaremos estas librerías para utilizar sus elementos.
 \end{frame}
 
\justify\subsection{Construcción de un circuito cuántico}
\begin{frame}[fragile]
\frametitle{Compuertas cuanticas} 
Para construir un circuito cuántico tenemos diferentes elementos y funciones que nos ayudaran con esta tarea, para ello vamos a conocer cada uno junto a su comportamiento correspondiente.
 \textbf{Las Compuertas de Pauli:}
     Debe estar familiarizado con las matrices de Pauli de la sección de álgebra lineal. Todas estas matrices o compuertas serán las utilizadas para manejar los qbits en nuestro circuito.
\end{frame}

%--------------------------------------------------------------------------------------

     \subsection{Compuertas de un solo qbit}
     \begin{frame}[fragile]
     \frametitle{Compuerta X} 
     Referida comúnmente como NOT-gate por su comportamiento análogo, la compuerta X da una rotación de $\pi$ radianes en  la esfera de Bloch, lo que sería igual decir que cambia el signo de nuestro qbit.
     
    Su visualización matemática es la siguiente:

    \begin{equation}
        X=\begin{bmatrix}
            0 & 1\\
            
            1 & 0
        \end{bmatrix}
    \end{equation}

     Mientras que su declaración en código es la siguiente:
     
      \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(1)
        Myqc.x(0)
        Myqc.draw() \end{lstlisting}
     \end{frame}
%--------------------------------------------------------------------------------------
     \newpage
    \begin{frame}[fragile]
     \frametitle{Compuerta Y & Z} 
    Al igual que la compuerta X, su comportamiento es el mismo dando una rotación en su eje respectivo.
    Su visualización matemática es la siguiente:

     \begin{columns}
     \column{0.5\textwidth}
       \begin{equation}
        Y=\begin{bmatrix}
            0 & -i\\
            i & 0
        \end{bmatrix}
        \end{equation}
        
    \column{0.5\textwidth}
       \begin{equation}
        Z=\begin{bmatrix}
            1 & 0\\
            0 & -1
        \end{bmatrix}
        \end{equation}
    
    \end{columns} 
    Mientras que su declaración en código es la siguiente:
      \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(1)
        Myqc.y(0)
        Myqc.z(0)
        Myqc.draw() \end{lstlisting}
        \end{frame}
   
%--------------------------------------------------------------------------------------    
    \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Hadamard(H)} 
     Una de las compuertas más usadas, su comportamiento nos ayuda a realizar dos rotaciones de manera simultánea, lo que genera un estado de superposición de |0⟩ y |1⟩. La rotación es equivalente una de  $\pi$ sobre el eje $\widehat {z}$ seguido de una rotación de  $\pi$/2 sobre el eje $\widehat {y}$.
     
      Su visualización matemática es la siguiente:
     
       \begin{equation}
        H=\frac{1}{\sqrt{2}}\begin{bmatrix}
            1 & 1\\
            1 & -1
        \end{bmatrix}
        \end{equation}
     
     Mientras que su declaración en código es la siguiente:
     
      \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(1)
        Myqc.h(0)
        Myqc.draw() \end{lstlisting}
    \end{frame} 
%--------------------------------------------------------------------------------------
    \newpage
    \begin{frame}[fragile]
    \frametitle{Compuerta Rotación(R)} 
     Esta compuerta nos es muy útil para cuando de trabajar con rotaciones se trata, el principio es darle al qbit una rotación parametrizada para desplazarlo por toda la esfera de Bloch. Necesita un ángulo $\phi$ para decirle exactamente a donde ir.
     
      Su visualización matemática es la siguiente:
     
      \begin{equation}
        R_{\phi}=\begin{bmatrix}
            1 & 0\\
            0 & e^{i\phi}
        \end{bmatrix}
        \end{equation}
    \end{frame}    
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Rotación(R)} 
    Mientras que su declaración en código es la siguiente:
     
        \begin{lstlisting}[language=Python]
        from math import pi, sqrt
        Myqc = QuantumCircuit(1)
        Myqc.rx(pi/4,0) #angle , target qbit
        Myqc.draw() \end{lstlisting}
    \end{frame}     
%--------------------------------------------------------------------------------------
    \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Tolerant(T)}
     Muchas aplicaciones cuánticas crearan compuertas por error debido al ruido, campos magnéticos, etc, para evitar esto se trata de generar un codificador que haga más robusta la transmisión de información. La compuerta Tolerante (Fault-Tolerant) nos ayuda con este problema, aunque si bien es efectiva siempre existe un rango de error aproximadamente a: {$\phi$} + 0.00000001. Siempre tendremos un límite en las aplicaciones que realicemos o las veces que usemos esta compuerta.
     
     Su rotación es en el eje Z al por {$\phi$} = {$\pi$}/4.
     \end{frame}  
     
    \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Tolerant(T)}
     Su declaración en código es la siguiente:
     
       \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(1)
        Myqc.t(0)
        Myqc.draw() \end{lstlisting}
    \end{frame} 
%-------------------------------------------------------------------------------------    
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Identidad(I)}
    Aunque parezca muy sencilla de entender, la compuerta identidad es la compuerta 1 a 1 con el qbit que es inicializado, básicamente no modifica nada en cuanto a datos se refiere. Aunque, es útil conocerla puesto que esta se conforma de dos o más compuertas, una de las más vitales es la compuerta X, la compuerta identidad será igual al producto de dos compuertas X.
     \end{frame} 
     
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Identidad(I)} 
    Su visualización matemática es la siguiente:
     
      \begin{equation}
        I =\begin{bmatrix}
            1 & 0\\
            0 & 1
        \end{bmatrix}
        \end{equation}
     
    Al ser una compuerta cuyo resultado es siempre la compuerta original, queda a disposición del lector deducir como obtener dicho resultado con las compuertas hasta ahora vistas.
      \end{frame} 
     
%-------------------------------------------------------------------------------------     
    \newpage\subsection{Compuertas de dos o mas qbit}
    \begin{frame}[fragile]
    \frametitle{Compuerta Control (CNOT)}
     Esta compuerta es muy utilizada en varias aplicaciones, esta compuerta basa su comportamiento cambiando de signo a un qbit por medio de otro qbit de control, es por ello su nombre. Dependiendo de cuál sea el eje que queramos manejar será el tipo de control (x,y o z) que debamos utilizar.
     
    Su visualización matemática es la siguiente:
     
      \begin{equation}
        CNOT =\begin{bmatrix}
            1 & 0 & 0 & 0\\
            0 & 1 & 0 & 0\\
            0 & 0 & 0 & 1\\
            0 & 0 & 1 & 0\\
        \end{bmatrix}
        \end{equation}
        \end{frame} 
%-------------------------------------------------------------------------------------        
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Control (CNOT)}
     Mientras que su declaración en código es la siguiente:
     
      \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(2)
        Myqc.cx(0,1)
        Myqc.cy(0,1)
        Myqc.cz(0,1)
        Myqc.draw() \end{lstlisting}
    \end{frame}  
%-------------------------------------------------------------------------------------    
    \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Toffoli (CCNOT)}
     Funcionando casi igual a la anterior, funcionando con tres qbits, dos de control y uno a controlar o target.
     
     Su visualización matemática es la siguiente:
     
      \begin{equation}
        CNOT =\begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
            0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
        \end{bmatrix}
        \end{equation}
     \end{frame}
%-------------------------------------------------------------------------------------
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Toffoli (CCNOT)}
     
    Mientras que su declaración en código es la siguiente:
     
    \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(3)
        Myqc.ccx(0,1,2)
        Myqc.draw() \end{lstlisting}
     \end{frame} 
%-------------------------------------------------------------------------------------
    \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Swap}
   Algunas veces necesitaremos realizar rotaciones sobre los qbits para realizar cambios de estado o transportar información de un carril a otro, por ello esta condición nos ayuda a realizar dicha tarea y es mucho más efectivo que igualar estados mediante otras compuertas.
     
    Su visualización matemática es la siguiente:
     
       \begin{equation}
        SWAP =\begin{bmatrix}
            1 & 0 & 0 & 0\\
            0 & 0 & 1 & 0\\
            0 & 1 & 0 & 0\\
            0 & 0 & 0 & 1\\
        \end{bmatrix}
        \end{equation}
    \end{frame}  
%-------------------------------------------------------------------------------------
     \newpage\begin{frame}[fragile]
     \frametitle{Compuerta Swap}
    Mientras que su declaración en código es la siguiente:
     
      \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(2)
        Myqc.swap(1,2)
        Myqc.draw() \end{lstlisting}
    \end{frame}  
%-------------------------------------------------------------------------------------
\newpage\subsection{Visualización de circuitos cuanticos}
 \setlength{\parskip}{0.5mm}
 \justify
  \begin{frame}
   \frametitle{Visualización de circuitos cuanticos} 
Ahora ya que tenemos construido nuestro circuito, naturalmente tendremos la curiosidad de observar si lo que hemos declarado en nuestra sintaxis ha sido justamente lo que queríamos, para ello tendremos diferentes maneras de ver nuestros circuitos cuánticos mediante varias herramientas.
 \end{frame}
 
   \newpage\begin{frame}[fragile]
   \frametitle{Construcción por ASCII} 
    Para mostrar un circuito de forma sencilla basta con utilizar la siguiente instrucción:
    
    \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(2)
        Myqc.x(0)
        Myqc.cx(0,1)
        print(Myqc) \end{lstlisting} 
        \centering\includegraphics[width = 0.3\textwidth]{ascii.JPG}
        
        Mediante el comando print, se crea un circuito de forma ASCII que es bastante sencillo de interpretar.
     \end{frame}
%------------------------------------------------------------------------------     
    \newpage\begin{frame}[fragile]
   \frametitle{Construcción por Matplotlib} 
    Para mostrar un circuito con una construcción visualmente elaborada se utiliza la siguiente instrucción:
    
     \begin{lstlisting}[language=Python]
        Myqc = QuantumCircuit(2)
        Myqc.x(0)
        Myqc.cx(0,1)
        Myqc.draw(output = 'mpl') \end{lstlisting} 
    \centering\includegraphics[width = 0.3\textwidth]{mpl.JPG}
    
    Mediante el comando draw el circuito pasa por un tratado en matplotlib cuando le indicamos este tipo de salida (output = 'mpl).
     \end{frame}
%------------------------------------------------------------------------------ 
   \newpage\subsection{Visualización de resultados}
    \setlength{\parskip}{0.5mm}
   \begin{frame}[fragile]
   \frametitle{Resultado por QASM}
  Es de los simuladores más utilizados para obtener los resultados de un circuito cuántico, lo que nos arroja son todos los resultados calculados para cada una de las posibles combinaciones de los qbtis en nuestro circuito. Incluye modelos de ruido altamente configurables e incluso se puede cargar con modelos de ruido aproximados generados automáticamente en función de los parámetros de calibración de los dispositivos de hardware reales.
   Para llamarlo, se necesita la siguiente instrucción:

    \begin{lstlisting}[language=Python]
    sim = Aer.get_backend(’qasm_simulator’) \end{lstlisting} 
   
   \end{frame}
%------------------------------------------------------------------------------ 
    \begin{frame}[fragile]
   \frametitle{Resultado por state vector}
   Simula la ejecución ideal de un circuito cuántico y devuelve el vector de estado cuántico final del dispositivo al final de la simulación. Esto es útil para la educación, así como para el estudio teórico y la depuración de algoritmos.
   Para llamarlo, se necesita la siguiente instrucción:
   \begin{lstlisting}[language=Python]
    sim = Aer.get_backend(’statevector_simulator’) \end{lstlisting} 
   \end{frame}
%------------------------------------------------------------------------------ 
   \begin{frame}[fragile]
   \frametitle{Resultado por esfera de Bloch}  
   Más que visualizar un circuito cuántico, estaremos viendo el resultado de los qbits por medio de la esfera de Bloch para ver su posición final pero es una excelente manera de interpretar un circuito cuántico final.
    Para ello se necesitan seguir los siguientes pasos:
    
    Primero necesitamos llamar a las siguientes librerías y módulos:

    
     \begin{lstlisting}[language=Python]
    from qiskit import QuantumCircuit, assemble, Aer
    from qiskit.visualization import plot_bloch_multivector, plot_histogram
    sim = Aer.get_backend('aer_simulator') \end{lstlisting} 
        
     Estas contienen los recursos necesarios para graficar dicha esfera, por lo que requieren un primer simulador que nos ayude a obtener el resultado del circuito.
     
     \end{frame}
     
    \newpage\begin{frame}[fragile]
    \frametitle{Construcción por esfera de Bloch} 
    Una vez hecho, construimos nuestro circuito de la misma manera que hemos hecho antes.
    \begin{lstlisting}[language=Python]
       Myqc = QuantumCircuit (2)
       Myqc.x(0)
       Myqc.cx(1,0)\end{lstlisting}
     
     En teoría, nuestro circuito nos debe arrojar un qbit en estado bajo y otro en alto. Para lograr ver esto necesitamos llamar a las siguientes instrucciones.
    \end{frame}
    
    \newpage\begin{frame}[fragile]
    \frametitle{Construcción por esfera de Bloch} 
   Para finalizar, debemos almacenar el estado en el que se encuentran nuestros qbits, después de guardarlos lo que hacemos es pasarlos por el simulador para que obtengamos los resultados de dicho experimento y por último, mostramos la esfera con los vectores en las posiciones que el simulador cálculo.
    
    \begin{lstlisting}[language=Python]
      Myqc.save_statevector()
      qobj = assemble(Myqc)
      state = sim.run(qobj).result().get_statevector()
      plot_bloch_multivector(state)\end{lstlisting}
 
    \end{frame}
    \newpage\begin{frame}
    \frametitle{Construcción por esfera de Bloch} 
    \centering\includegraphics[width = 0.75\textwidth]{bloch.JPG}
    \end{frame}
\section{Herramientas en la nube}        
 \setlength{\parskip}{1mm}
 \begin{frame}[fragile]
 \frametitle{IBM Quantum Experience} 
 \justify    
 Incluso con todo lo anterior, si necesitamos más herramientas para trabajar en computación cuántica o requerimos aplicaciones donde la computación cuántica es una herramienta fundamental, tenemos en la nube diferentes opciones para trabajar de manera gratuita con la computación cuántica. Nuevamente, son simuladores de alta precisión debido al ruido que estas máquinas llegan a capturar.
 
 Ejemplo de esto es la IBM Quantum Experience donde podremos trabajar en tiempo real con una de las múltiples computadoras cuánticas que nos ofrece la compañía. Aprendamos un poco como seleccionar un buen modelo para empezar a trabajar y conocer el ambiente.
 
 Para acceder a la herramienta, hay que dirigirnos a esta página:  \url{https://quantum-computing.ibm.com/}

 \end{frame}
 
 \newpage\begin{frame}
 \frametitle{IBM Quantum Experience} 
 \justify 
Entrando al link anterior, nos encontraremos esta página de bienvenida donde podemos interactuar par conocer un poco más sobre la forma de trabajar de la mano de IBM. Para registrarnos, debemos hacer click en el botón azul que dice IBMid.
 
 \centering\includegraphics[width = 1\textwidth]{Diapositiva1.JPG}
 \end{frame}
 
 \newpage\begin{frame}
 \frametitle{IBM Quantum Experience} 
 \justify 
 Una vez entrando, nos pedirá nuestros datos personales para poder pasar a aceptar un acuerdo de uso con la herramienta virtual de IBM, asegurarse de leer completamente el acuerdo de uso. Una vez hecho esto, podemos dar en el botón azul y seguir con la aplicación.
 
 \centering\includegraphics[width = 0.8\textwidth]{Diapositiva2.JPG}
 \end{frame}
 
 \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
 Avanzaremos hasta lo que es nuestra página de inicio de sesión de usuario, en esta se encuentran diferentes opciones como el laboratorio de IBM para escribir código, el simulador de una computadora cuántica y varias opciones más, lo que hoy nos llama es entrar a la parte del Composer, el cual es el botón azul que dice "Lauch Composer".
 
 \centering\includegraphics[width = 0.75\textwidth]{Diapositiva3.JPG}
 \end{frame}
 
  \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
En esta parte podemos disfrutar de una herramienta muy completa para desarrollar circuitos cuánticos, conozcamos un poco más nuestro ambiente. 
 
 \centering\includegraphics[width = 0.90\textwidth]{Diapositiva4.JPG}
 \end{frame}
 
  \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
 Primero que nada, tenemos nuestro diseñador de circuitos cuánticos, junto a todas las compuertas cuánticas que podremos llegar necesitar, desde las más básicas hasta las más complicadas.
 
 \centering\includegraphics[width = 0.90\textwidth]{Diapositiva5.JPG}
 \end{frame}
 
  \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
 Segundo, cuando terminemos de diseñar nuestro circuito y queramos ver los resultados en forma gráfica y de porcentajes de que ocurran, tenemos esta útil grafica que nos facilita el trabajo.
 
 \centering\includegraphics[width = 0.75\textwidth]{Diapositiva6.JPG}
 \end{frame}
 
  \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
 Tercero, nuestra esfera de Bloch móvil donde podemos ver la dirección de nuestros vectores en tiempo real, logrando intercalar entre estado y ángulo de fase.
 
 \centering\includegraphics[width = 0.75\textwidth]{Diapositiva7.JPG}
 \end{frame}
 
 \newpage\justify \begin{frame}
 \frametitle{IBM Quantum Experience} 
Cuarto y último, si preferimos probar la entrada por código tenemos una sencilla interfaz para el trabajo, con disponibilidad para usar el lenguaje OpenQASM 2.0 o una versión de Python con Qiskit.
 
 \centering\includegraphics[width = 0.75\textwidth]{Diapositiva8.JPG}
 \end{frame}
 
\end{document}